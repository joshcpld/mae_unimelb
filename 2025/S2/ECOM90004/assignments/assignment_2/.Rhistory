k <- if(!is.na(kcap[n])) as.integer(kcap[n]) else 5            # use [] for named vector lookup
t <- ur.df(resid(models[[n]]), type="drift", lags=k, selectlags="AIC")
p <- punitroot(t@teststat[1], trend="c", statistic="t")
adf_p <- rbind(adf_p, data.frame(model=n, max_lags_used=k, best_lag_AIC=t@lags, tau_stat=t@teststat[1], p_value=p))
}
row.names(adf_p) <- NULL
print(adf_p)
kcap   <- c(Linear=5, `One break`=4, `Two breaks`=4)
adf_p <- data.frame()
kcap   <- c(Linear=5, `One break`=4, `Two breaks`=4)
adf_p <- data.frame()
for(n in names(models)){
k <- kcap[n]                                                # use model-specific cap
t <- ur.df(resid(models[[n]]), type="drift", lags=k, selectlags="AIC")
p <- punitroot(t@teststat[1], trend="c", statistic="t")     # constant/drift, no trend
adf_p <- rbind(adf_p, data.frame(model=n, max_lags_used=k, best_lag_AIC=t@lags,
tau_stat=t@teststat[1], p_value=p))
}
row.names(adf_p) <- NULL
print(adf_p)
# function: fit AR(p) to residuals (Z), compute AICc & Ljung–Box, mark min AICc
resid_ar_table<-function(model,label,pmax=9){
Z<-resid(model); AICc<-LBp<-numeric(pmax+1)                               # store values
for(p in 0:pmax){                                                          # loop over p
eq<-Arima(Z,order=c(p,0,0),include.mean=FALSE,method="ML")              # AR(p) fit
AICc[p+1]<-eq$aicc                                                       # record AICc
LBp[p+1]<-Box.test(residuals(eq),lag=p+4,type="Ljung-Box",fitdf=p)$p.value # Ljung–Box
}
Stats<-matrix("",nrow=pmax+1,ncol=3,                                       # results table
library(tidyverse)
library(lubridate)
library(forecast)
library(urca)
theme_set(theme_minimal())
data <- read_csv("USRealGDPPerCapita.csv") %>%
select(date = observation_date, value = RealGDPPerCap) %>%
mutate(date = dmy(date)) %>%
mutate(value = log(value)) %>%
na.omit() %>%
# Variables for models
mutate(time = row_number()*0.25) %>%
mutate(du_1 = if_else(lubridate::year(date) > 1973, 1, 0), dt_1 = if_else(year(date) > 1973, time, 0)) %>%
mutate(du_2 = if_else(lubridate::year(date) > 2008, 1, 0), dt_2 = if_else(year(date) > 2008, time, 0))
linear_model <- lm(value ~ time, data = data)
one_break_model <- lm(value ~ time + du_1 + dt_1, data = data)
two_break_model <- lm(value ~ time + du_1 + dt_1 + du_2 + dt_2, data = data)
tab <- cbind(
"Linear model (a)"  = coef(linear_model)[c("(Intercept)","time","du_1","dt_1","du_2","dt_2")],
"1 break model (b)" = coef(one_break_model)[c("(Intercept)","time","du_1","dt_1","du_2","dt_2")],
"2 break model (c)" = coef(two_break_model)[c("(Intercept)","time","du_1","dt_1","du_2","dt_2")]
)
rownames(tab) <- c("beta_0","beta_1","beta_3","beta_4","beta_5")
round(tab, 4)
rownames(tab) <- c("beta_0","beta_1","beta_3","beta_4","beta_5")
tab <- cbind(
"Linear model (a)"  = coef(linear_model)[c("(Intercept)","time","du_1","dt_1","du_2","dt_2")],
"1 break model (b)" = coef(one_break_model)[c("(Intercept)","time","du_1","dt_1","du_2","dt_2")],
"2 break model (c)" = coef(two_break_model)[c("(Intercept)","time","du_1","dt_1","du_2","dt_2")]
)
rownames(tab) <- c("beta_0","time", "beta_1","beta_3","beta_4","beta_5")
round(tab, 4)
models <- list(linear_model, one_break_model, two_break_model)
labs <- c("Linear model", "One-break model", "Two-break model")
invisible(lapply(seq_along(models), function(i){
m <- mods[[i]]; lab <- labs[i]
aug <- data.frame(date = data$date, value = data$value, fitted = fitted(m), residuals = resid(m))
p1 <- ggplot(aug, aes(date, value)) + geom_line() + geom_line(aes(y = fitted), color = "red", linewidth = 1) +
labs(title = paste0("Chart ", (i-1)*2+1, ": ", lab, " \n fitted values"), x = "date", y = "value")
p2 <- ggplot(aug, aes(date, residuals)) + geom_line() + geom_hline(yintercept = 0, linetype = "dashed") +
labs(title = paste0("Chart ", (i-1)*2+2, ": ", lab, " \n residuals"), x = "date", y = "residuals")
ggsave(paste0("chart", (i-1)*2+1, ".png"), p1, width = 3, height = 2.5, units = "in", dpi = 300)
ggsave(paste0("chart", (i-1)*2+2, ".png"), p2, width = 3, height = 2.5, units = "in", dpi = 300)
}))
m <- models[[i]]; lab <- labs[i]
invisible(lapply(seq_along(models), function(i){
m <- models[[i]]; lab <- labs[i]
aug <- data.frame(date = data$date, value = data$value, fitted = fitted(m), residuals = resid(m))
p1 <- ggplot(aug, aes(date, value)) + geom_line() + geom_line(aes(y = fitted), color = "red", linewidth = 1) +
labs(title = paste0("Chart ", (i-1)*2+1, ": ", lab, " \n fitted values"), x = "date", y = "value")
p2 <- ggplot(aug, aes(date, residuals)) + geom_line() + geom_hline(yintercept = 0, linetype = "dashed") +
labs(title = paste0("Chart ", (i-1)*2+2, ": ", lab, " \n residuals"), x = "date", y = "residuals")
ggsave(paste0("chart", (i-1)*2+1, ".png"), p1, width = 3, height = 2.5, units = "in", dpi = 300)
ggsave(paste0("chart", (i-1)*2+2, ".png"), p2, width = 3, height = 2.5, units = "in", dpi = 300)
}))
round(tab, 4)
b <- coef(two_break_model)
V <- vcov(two_break_model)
# function: fit AR(p) to residuals (Z), compute AICc & Ljung–Box, mark min AICc
resid_ar_table<-function(model,label,pmax=9){
Z<-resid(model); AICc<-LBp<-numeric(pmax+1)                               # store values
for(p in 0:pmax){                                                          # loop over p
eq<-Arima(Z,order=c(p,0,0),include.mean=FALSE,method="ML")              # AR(p) fit
AICc[p+1]<-eq$aicc                                                       # record AICc
LBp[p+1]<-Box.test(residuals(eq),lag=p+4,type="Ljung-Box",fitdf=p)$p.value # Ljung–Box
}
Stats<-matrix("",nrow=pmax+1,ncol=3,                                       # results table
dimnames=list(paste0("p=",0:pmax),c("  LBp","  AICc","minAICc")))
Stats[,1]<-format(round(LBp,4),nsmall=4)                                   # fill LBp
Stats[,2]<-format(round(AICc,2),nsmall=2)                                  # fill AICc
Stats[which.min(AICc),3]<-"<="                                             # flag min AICc
cat("\n",label,"\n",sep=""); print(Stats,quote=FALSE)                      # print table
data.frame(model=label,p=which.min(AICc)-1,                                # return summary
AICc=min(AICc),LB_p=LBp[which.min(AICc)])
}
# run loop for each model
final<-data.frame()
for(n in names(models)) final<-rbind(final,resid_ar_table(models[[n]],n,pmax=9))
# final AR order selection
print(final)
# function: fit AR(p) to residuals (Z), compute AICc & Ljung–Box, mark min AICc
resid_ar_table<-function(model,label,pmax=9){
Z<-resid(model); AICc<-LBp<-numeric(pmax+1)                               # store values
for(p in 0:pmax){                                                          # loop over p
eq<-Arima(Z,order=c(p,0,0),include.mean=FALSE,method="ML")              # AR(p) fit
AICc[p+1]<-eq$aicc                                                       # record AICc
LBp[p+1]<-Box.test(residuals(eq),lag=p+4,type="Ljung-Box",fitdf=p)$p.value # Ljung–Box
}
Stats<-matrix("",nrow=pmax+1,ncol=3,                                       # results table
dimnames=list(paste0("p=",0:pmax),c("  LBp","  AICc","minAICc")))
Stats[,1]<-format(round(LBp,4),nsmall=4)                                   # fill LBp
Stats[,2]<-format(round(AICc,2),nsmall=2)                                  # fill AICc
Stats[which.min(AICc),3]<-"<="                                             # flag min AICc
cat("\n",label,"\n",sep=""); print(Stats,quote=FALSE)                      # print table
data.frame(model=label,p=which.min(AICc)-1,                                # return summary
AICc=min(AICc),LB_p=LBp[which.min(AICc)])
}
# run loop for each model
final<-data.frame()
for(n in names(models)) final<-rbind(final,resid_ar_table(models[[n]],n,pmax=9))
# final AR order selection
print(final)
final <- data.frame()
for(n in names(models))
final <- rbind(final, resid_ar_table(models[[n]], n, pmax=9))
# function: fit AR(p) to residuals (Z), compute AICc & Ljung–Box, mark min AICc
resid_ar_table<-function(model,label,pmax=9){
Z<-resid(model); AICc<-LBp<-numeric(pmax+1)                               # store values
for(p in 0:pmax){                                                          # loop over p
eq<-Arima(Z,order=c(p,0,0),include.mean=FALSE,method="ML")              # AR(p) fit
AICc[p+1]<-eq$aicc                                                       # record AICc
LBp[p+1]<-Box.test(residuals(eq),lag=p+4,type="Ljung-Box",fitdf=p)$p.value # Ljung–Box
}
Stats<-matrix("",nrow=pmax+1,ncol=3,                                       # results table
dimnames=list(paste0("p=",0:pmax),c("  LBp","  AICc","minAICc")))
Stats[,1]<-format(round(LBp,4),nsmall=4)                                   # fill LBp
Stats[,2]<-format(round(AICc,2),nsmall=2)                                  # fill AICc
Stats[which.min(AICc),3]<-"<="                                             # flag min AICc
cat("\n",label,"\n",sep=""); print(Stats,quote=FALSE)                      # print table
data.frame(model=label,p=which.min(AICc)-1,                                # return summary
AICc=min(AICc),LB_p=LBp[which.min(AICc)])
}
final <- do.call(rbind, lapply(names(models), function(n)
resid_ar_table(models[[n]], n, pmax=9)))
print(final)
# function: fit AR(p) to residuals (Z), compute AICc & Ljung–Box, mark min AICc
resid_ar_table<-function(model,label,pmax=9){
Z<-resid(models); AICc<-LBp<-numeric(pmax+1)                               # store values
for(p in 0:pmax){                                                          # loop over p
eq<-Arima(Z,order=c(p,0,0),include.mean=FALSE,method="ML")              # AR(p) fit
AICc[p+1]<-eq$aicc                                                       # record AICc
LBp[p+1]<-Box.test(residuals(eq),lag=p+4,type="Ljung-Box",fitdf=p)$p.value # Ljung–Box
}
Stats<-matrix("",nrow=pmax+1,ncol=3,                                       # results table
dimnames=list(paste0("p=",0:pmax),c("  LBp","  AICc","minAICc")))
Stats[,1]<-format(round(LBp,4),nsmall=4)                                   # fill LBp
Stats[,2]<-format(round(AICc,2),nsmall=2)                                  # fill AICc
Stats[which.min(AICc),3]<-"<="                                             # flag min AICc
cat("\n",label,"\n",sep=""); print(Stats,quote=FALSE)                      # print table
data.frame(model=label,p=which.min(AICc)-1,                                # return summary
AICc=min(AICc),LB_p=LBp[which.min(AICc)])
}
final <- do.call(rbind, lapply(names(models), function(n)
resid_ar_table(models[[n]], n, pmax=9)))
print(final)
# function: fit AR(p) to residuals (Z), compute AICc & Ljung–Box, mark min AICc
resid_ar_table<-function(models,label,pmax=9){
Z<-resid(models); AICc<-LBp<-numeric(pmax+1)                               # store values
for(p in 0:pmax){                                                          # loop over p
eq<-Arima(Z,order=c(p,0,0),include.mean=FALSE,method="ML")              # AR(p) fit
AICc[p+1]<-eq$aicc                                                       # record AICc
LBp[p+1]<-Box.test(residuals(eq),lag=p+4,type="Ljung-Box",fitdf=p)$p.value # Ljung–Box
}
Stats<-matrix("",nrow=pmax+1,ncol=3,                                       # results table
dimnames=list(paste0("p=",0:pmax),c("  LBp","  AICc","minAICc")))
Stats[,1]<-format(round(LBp,4),nsmall=4)                                   # fill LBp
Stats[,2]<-format(round(AICc,2),nsmall=2)                                  # fill AICc
Stats[which.min(AICc),3]<-"<="                                             # flag min AICc
cat("\n",label,"\n",sep=""); print(Stats,quote=FALSE)                      # print table
data.frame(model=label,p=which.min(AICc)-1,                                # return summary
AICc=min(AICc),LB_p=LBp[which.min(AICc)])
}
final <- do.call(rbind, lapply(names(models), function(n)
resid_ar_table(models[[n]], n, pmax=9)))
print(final)
resid_ar_table <- function(model, label, pmax = 9) {
Z <- resid(model); AICc <- LBp <- numeric(pmax + 1)
for (p in 0:pmax) {
eq <- Arima(Z, order = c(p, 0, 0), include.mean = FALSE, method = "ML")
AICc[p + 1] <- eq$aicc
LBp[p + 1] <- Box.test(residuals(eq), lag = p + 4,
type = "Ljung-Box", fitdf = p)$p.value
}
Stats <- cbind(
sprintf("%.4f", LBp),
sprintf("%.2f", AICc),
replace(rep("", pmax + 1), which.min(AICc), "<=")
)
rownames(Stats) <- paste0("p=", 0:pmax); colnames(Stats) <- c("LBp", "AICc", "minAICc")
cat("\n", label, "\n", sep = ""); print(Stats, quote = FALSE)
data.frame(model = label, p = which.min(AICc) - 1,
AICc = min(AICc), LB_p = LBp[which.min(AICc)])
}
# give names to models and run
models <- list(linear_model, one_break_model, two_break_model)
names(models) <- c("linear_model", "one_break_model", "two_break_model")
final <- do.call(rbind, Map(function(m, lab) resid_ar_table(m, lab, pmax = 9),
models, names(models)))
print(final)
library(tidyverse)
library(tidyverse)
library(lubridate)
library(forecast)
library(urca)
theme_set(theme_minimal())
data <- read_csv("USRealGDPPerCapita.csv") %>%
select(date = observation_date, value = RealGDPPerCap) %>%
mutate(date = dmy(date)) %>%
mutate(value = log(value)) %>%
na.omit() %>%
# Variables for models
mutate(time = row_number()*0.25) %>%
mutate(du_1 = if_else(lubridate::year(date) > 1973, 1, 0), dt_1 = if_else(year(date) > 1973, time, 0)) %>%
mutate(du_2 = if_else(lubridate::year(date) > 2008, 1, 0), dt_2 = if_else(year(date) > 2008, time, 0))
linear_model <- lm(value ~ time, data = data)
one_break_model <- lm(value ~ time + du_1 + dt_1, data = data)
two_break_model <- lm(value ~ time + du_1 + dt_1 + du_2 + dt_2, data = data)
tab <- cbind(
"Linear model (a)"  = coef(linear_model)[c("(Intercept)","time","du_1","dt_1","du_2","dt_2")],
"1 break model (b)" = coef(one_break_model)[c("(Intercept)","time","du_1","dt_1","du_2","dt_2")],
"2 break model (c)" = coef(two_break_model)[c("(Intercept)","time","du_1","dt_1","du_2","dt_2")]
)
rownames(tab) <- c("beta_0","time", "beta_1","beta_3","beta_4","beta_5")
round(tab, 4)
models <- list(linear_model, one_break_model, two_break_model)
labs <- c("Linear model", "One-break model", "Two-break model")
invisible(lapply(seq_along(models), function(i){
m <- models[[i]]; lab <- labs[i]
aug <- data.frame(date = data$date, value = data$value, fitted = fitted(m), residuals = resid(m))
p1 <- ggplot(aug, aes(date, value)) + geom_line() + geom_line(aes(y = fitted), color = "red", linewidth = 1) +
labs(title = paste0("Chart ", (i-1)*2+1, ": ", lab, " \n fitted values"), x = "date", y = "value")
p2 <- ggplot(aug, aes(date, residuals)) + geom_line() + geom_hline(yintercept = 0, linetype = "dashed") +
labs(title = paste0("Chart ", (i-1)*2+2, ": ", lab, " \n residuals"), x = "date", y = "residuals")
ggsave(paste0("chart", (i-1)*2+1, ".png"), p1, width = 3, height = 2.5, units = "in", dpi = 300)
ggsave(paste0("chart", (i-1)*2+2, ".png"), p2, width = 3, height = 2.5, units = "in", dpi = 300)
}))
resid_ar_table <- function(model, label, pmax = 9) {
Z <- resid(model); AICc <- LBp <- numeric(pmax + 1)
for (p in 0:pmax) {
eq <- Arima(Z, order = c(p, 0, 0), include.mean = FALSE, method = "ML")
AICc[p + 1] <- eq$aicc
LBp[p + 1] <- Box.test(residuals(eq), lag = p + 4,
type = "Ljung-Box", fitdf = p)$p.value
}
Stats <- cbind(
sprintf("%.4f", LBp),
sprintf("%.2f", AICc),
replace(rep("", pmax + 1), which.min(AICc), "<=")
)
rownames(Stats) <- paste0("p=", 0:pmax); colnames(Stats) <- c("LBp", "AICc", "minAICc")
cat("\n", label, "\n", sep = ""); print(Stats, quote = FALSE)
data.frame(model = label, p = which.min(AICc) - 1,
AICc = min(AICc), LB_p = LBp[which.min(AICc)])
}
names(models) <- c("linear_model", "one_break_model", "two_break_model")
final <- do.call(rbind, Map(function(m, lab) resid_ar_table(m, lab, pmax = 9),
models, names(models)))
final <- do.call(rbind, Map(function(m, lab) resid_ar_table(m, lab, pmax = 9),
models, names(models)))
print(final)
kcap   <- c(Linear=5, `One break`=4, `Two breaks`=4)
adf_p <- data.frame()
for(n in names(models)){
k <- kcap[n]                                                # use model-specific cap
t <- ur.df(resid(models[[n]]), type="drift", lags=k, selectlags="AIC")
p <- punitroot(t@teststat[1], trend="c", statistic="t")     # constant/drift, no trend
adf_p <- rbind(adf_p, data.frame(model=n, max_lags_used=k, best_lag_AIC=t@lags,
tau_stat=t@teststat[1], p_value=p))
}
# function: ADF on residuals -> p-value (constant non-zero mean)
adf_resid_row <- function(m, lab, lmax){
Z <- resid(m)                                                 # residuals
adf <- ur.df(Z, type="drift", selectlags="AIC", lags=lmax)    # ADF with drift, lag selected by AIC (<= lmax)
p  <- punitroot(adf@teststat[1], trend="c", statistic="t")     # p-value, constant-only (non-zero mean)
data.frame(model=lab, lags_selected=adf@lags, t_stat=adf@teststat[1], p_value=p)
}
# run for all models and bind
adf_results <- do.call(rbind, Map(adf_resid_row, models, labels, lags_max))
lags_max <- c(4, 5, 5) # max lags per model: linear=4, others=5
# function: ADF on residuals -> p-value (constant non-zero mean)
adf_resid_row <- function(m, lab, lmax){
Z <- resid(m)                                                 # residuals
adf <- ur.df(Z, type="drift", selectlags="AIC", lags=lmax)    # ADF with drift, lag selected by AIC (<= lmax)
p  <- punitroot(adf@teststat[1], trend="c", statistic="t")     # p-value, constant-only (non-zero mean)
data.frame(model=lab, lags_selected=adf@lags, t_stat=adf@teststat[1], p_value=p)
}
# run for all models and bind
adf_results <- do.call(rbind, Map(adf_resid_row, models, labels, lags_max))
models <- list(linear_model, one_break_model, two_break_model)
labels <- c("linear_model", "one_break_model", "two_break_model")
lags_max <- c(4, 5, 5)  # linear=4, others=5
adf_resid_row <- function(m, lab, lmax){
Z   <- resid(m)                                            # residuals
adf <- ur.df(Z, type = "drift", selectlags = "AIC", lags = lmax)
tval <- unname(adf@teststat["tau2"])                       # t-stat for drift (constant/no trend)
p    <- urca::punitroot(tval, trend = "c", statistic = "t")# p-value under constant (non-zero mean)
data.frame(model = lab, lags_selected = adf@lags, t_stat = tval, p_value = p)
}
adf_results <- do.call(rbind, Map(adf_resid_row, models, labels, lags_max))
models <- list(linear_model, one_break_model, two_break_model)
labels <- c("linear_model", "one_break_model", "two_break_model")
lags_max <- c(4, 5, 5)  # linear=4, others=5
adf_resid_row <- function(m, lab, lmax){
Z   <- resid(m)
adf <- ur.df(Z, type = "drift", selectlags = "AIC", lags = lmax)
tval <- unname(adf@teststat["tau2"])          # test statistic for drift case
pval <- if (!is.na(tval)) {
urca::punitroot(tval, trend = "c", statistic = "t")
} else {
NA_real_
}
data.frame(model = lab, lags_selected = adf@lags,
t_stat = tval, p_value = pval)
}
adf_results <- do.call(rbind, Map(adf_resid_row, models, labels, lags_max))
print(adf_results)
Z <- resid(linear_model)
adf <- ur.df(Z, type = "drift", selectlags = "AIC", lags = 4)
summary(adf)
# models, labels, and max lags (linear=4, others=5)
models <- list(linear_model, one_break_model, two_break_model)
labels <- c("linear_model","one_break_model","two_break_model")
lags_max <- c(4,5,5)
# ADF on residuals with drift; return p-value via punitroot()
adf_resid_row <- function(m, lab, lmax){
Z <- resid(m)                                   # residual series
l <- lmax
repeat {                                        # step down lag cap if needed
adf  <- ur.df(Z, type="drift", selectlags="AIC", lags=l)
tval <- unname(adf@teststat["tau2"])          # drift case uses tau2
if (!is.na(tval) || l == 0) break
l <- l - 1
}
p <- if (!is.na(tval)) urca::punitroot(tval, trend="c", statistic="t") else NA_real_
data.frame(model=lab, max_lags=lmax, lags_selected=adf@lags, t_stat=tval, p_value=p)
}
# run and bind
adf_results <- do.call(rbind, Map(adf_resid_row, models, labels, lags_max))
print(adf_results)
# ADF on residuals with drift; return p-value via punitroot()
adf_resid_row <- function(m, lab, lmax){
Z <- resid(m)                                   # residual series
l <- lmax
repeat {                                        # step down lag cap if needed
adf  <- ur.df(Z, type="drift", selectlags="AIC", lags=l)
tval <- unname(adf@teststat["tau2"])          # drift case uses tau2
if (!is.na(tval) || l == 0) break
l <- l - 1
}
p <- if (!is.na(tval)) urca::punitroot(tval, trend="c", statistic="t") else NA_real_
data.frame(model=lab, max_lags=lmax, lags_selected=adf@lags, t_stat=tval, p_value=p)
}
# run and bind
adf_results <- do.call(rbind, Map(adf_resid_row, models, labels, lags_max))
print(adf_results)
# --- Linear model (max 4 lags) ---
adf_lin <- ur.df(resid(linear_model), type="drift", selectlags="AIC", lags=4)
p_lin   <- punitroot(adf_lin@teststat["tau2"], trend="c", statistic="t")
print(p_lin)
# --- Linear model (max 4 lags) ---
adf_lin <- ur.df(resid(linear_model), type="drift", selectlags="AIC", lags=4)
p_lin   <- punitroot(adf_lin@teststat["tau2"], trend="c", statistic="t")
summary = adf_lin
summary(adf_lin)
# --- Linear model (max 4 lags) ---
adf_lin <- ur.df(resid(linear_model), type="drift", selectlags="AIC", lags=4))
p_lin   <- punitroot(adf@teststat[1], trend="c", statistic="t")
p_lin   <- punitroot(adf@teststat[1], trend="c", statistic="t")
print(p_lin)
# function: ADF on residuals -> p-value
adf_resid_pval <- function(model, lmax) {
adf <- ur.df(resid(model), type="drift", selectlags="AIC", lags=lmax)
punitroot(adf@teststat[1], trend="c", statistic="t")
}
# models, labels, and lags
models <- list(linear_model, one_break_model, two_break_model)
labels <- c("linear_model","one_break_model","two_break_model")
lags   <- c(4,5,5)
# run all in one shot
pvals <- data.frame(model = labels,
p_value = Map(adf_resid_pval, models, lags))
print(pvals)
# models, labels, and max lags (linear=4, others=5)
models <- list(linear_model, one_break_model, two_break_model)
labels <- c("linear_model","one_break_model","two_break_model")
lags   <- c(4,5,5)
# compact ADF on residuals -> selected lag, t-stat, p-value (via punitroot)
adf_rows <- t(mapply(function(m, L) {
adf  <- ur.df(resid(m), type="drift", selectlags="AIC", lags=L)
tval <- as.numeric(adf@teststat[1])                # tau2 for 'drift'
pval <- urca::punitroot(tval, trend="c", statistic="t")
c(lag = adf@lags, t_stat = tval, p_value = pval)
}, models, lags, SIMPLIFY = TRUE))
adf_results <- data.frame(model = labels, adf_rows, row.names = NULL)
print(adf_results)
# models, labels, and max lags
models <- list(linear_model, one_break_model, two_break_model)
labels <- c("linear_model","one_break_model","two_break_model")
# function: simulate null (unit root) ADF t-stat with drift and AIC lag selection
sim_adf_cv5 <- function(n, L, B = 2000) {
tstats <- replicate(B, {
y <- cumsum(rnorm(n))                                # RW under H0
as.numeric(ur.df(y, type="drift", selectlags="AIC", lags=L)@teststat[1])
})
unname(quantile(tstats, 0.05, na.rm = TRUE))           # 5% critical value
}
# lengths of residuals per model
n_vec <- sapply(models, function(m) length(resid(m)))
# run sims and bind
cv5 <- mapply(sim_adf_cv5, n_vec, lags)
# run sims and bind
cv5 <- mapply(sim_adf_cv5, n_vec, lags)
cv_table <- data.frame(model = labels, n = n_vec, Lmax = lags, cv_5pct = cv5, row.names = NULL)
print(cv_table)
# simulate null distribution and compute 5% CV
sim_adf_cv5 <- function(n, L, reps = 2000) {
tstats <- replicate(reps, {
y <- cumsum(rnorm(n))                                  # random walk under H0
as.numeric(ur.df(y, type="drift", selectlags="AIC", lags=L)@teststat[1])
})
quantile(tstats, 0.05, na.rm = TRUE)
}
n_vec <- sapply(models, function(m) length(resid(m)))
cv5   <- mapply(sim_adf_cv5, n_vec, lags)
cv5   <- mapply(sim_adf_cv5, n_vec, lags)
cv_table <- data.frame(model = labels, n = n_vec, Lmax = lags, cv_5pct = cv5)
print(cv_table)
# Function: simulate null distribution of ADF t-stat and return 5% critical value
sim_adf_cv5 <- function(n, L, reps = 2000) {
tstats <- replicate(reps, {
y <- cumsum(rnorm(n))                                  # random walk under H0
as.numeric(ur.df(y, type="drift", selectlags="AIC", lags=L)@teststat[1])
})
quantile(tstats, 0.05, na.rm = TRUE)                     # 5% critical value
}
# Get sample sizes from residuals
n_vec <- sapply(models, function(m) length(resid(m)))
# Run simulation per model
cv5 <- mapply(sim_adf_cv5, n_vec, lags)
# Run simulation per model
cv5 <- mapply(sim_adf_cv5, n_vec, lags)
# Collect results in table
cv_table <- data.frame(model = labels, n = n_vec, Lmax = lags, cv_5pct = cv5)
print(cv_table)
# Observed ADF t statistics for residuals
obs_t <- numeric(length(models))
for(i in seq_along(models)){
adf <- ur.df(resid(models[[i]]), type="drift", selectlags="AIC", lags=lags[i])
obs_t[i] <- as.numeric(adf@teststat[1])                       # tau2 for drift
}
# Monte Carlo p-values from the saved null draws
pvals <- numeric(length(models))
library(tidyverse)
library(lubridate)
library(forecast)
library(urca)
theme_set(theme_minimal())
p_table <- data.frame(model = labels,
t_stat = round(obs_t, 4),
p_value = formatC(pvals, format="f", digits=4))
library(tidyverse)
library(lubridate)
library(forecast)
library(urca)
library(car)
# H0: no jump at 1973
linearHypothesis(two_break_model, "beta_3 + 1973*beta_4 = 0")
install.packages(car)
install.packages("car")
library(car)
install.packages("car")
library(car)
names(coef(two_break_model))
library(tidyverse)
library(tidyverse)
library(lubridate)
library(forecast)
library(urca)
library(car)
theme_set(theme_minimal())
data <- read_csv("USRealGDPPerCapita.csv") %>%
select(date = observation_date, value = RealGDPPerCap) %>%
mutate(date = dmy(date)) %>%
mutate(value = log(value)) %>%
na.omit() %>%
# Variables for models
mutate(time = row_number()*0.25) %>%
mutate(du_1 = if_else(lubridate::year(date) > 1973, 1, 0), dt_1 = if_else(year(date) > 1973, time, 0)) %>%
mutate(du_2 = if_else(lubridate::year(date) > 2008, 1, 0), dt_2 = if_else(year(date) > 2008, time, 0))
linear_model <- lm(value ~ time, data = data)
one_break_model <- lm(value ~ time + du_1 + dt_1, data = data)
two_break_model <- lm(value ~ time + du_1 + dt_1 + du_2 + dt_2, data = data)
names(coef(two_break_model))

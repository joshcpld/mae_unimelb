---
title: "Josh Copeland - ECOM90024 - Assignment 1"
---
title: "Josh Copeland - ECOM90024 - Assignment 1"
library(janitor)
theme_set(theme_minimal())
library(readxl)
library(tidyverse)
library(tidyverse)
library(readxl)
library(lubridate)
library(janitor)
theme_set(theme_minimal())
```{r librariers_used}
nile <- read_csv("nile.csv", show_col_types = FALSE) %>%
mutate(date = seq(as.Date("2017-01-01"),as.Date("2017-09-28"), by = "day")) %>%
select(date, hits = Hits) %>%
mutate(hits = hits / 1000)
ggplot(nile, aes(date, hits)) + geom_line() + scale_x_date(date_breaks = "1 month", date_label = "%b") + labs(x = "Date", y = "Hits (thousands)") + ggtitle("Chart 1: Daily hits to NILE.COM (01-01-2017 to 28-09-2017)")
<br>
### b.) Fit and assess the linear, quadratic and exponential trend models to the data. In your analysis, make sure to include the estimation results as well as appropriate plots of the fitted trends that you have generated. Given your results, which trend model would you choose as your forecasting model? Make sure to provide your reasoning. (1 Mark)
<br>
The analysis below estimates and fits linear, quadratic and exponential trend models to the hits data for NILE.COM. Chart 2 shows how well the fitted trends accord with the underlying data. Without further analysis, it seems that they all provide roughly the same fit.
To determine which model provides the best fit, it is important to use the relevant model selection criteria generated by each model: Akaike information criterion (AIC) and Bayesian information criterion (BIC). The function used to generate the exponential model uses a nonlinear least squares methodology, which makes the use/interpretation of any r-squared values complex. the nls() function does not generate this automatically and I have not attempted to create my own measure to make comparisons as simple as possible.
A comparison of the relevant model selection criteria, as summarised in the model_selection_criteria table below, shows us the linear model is the most appropriate for forecasting. This is because it has the lowest AIC and BIC values relative to the other two.
<br>
```{r q1b}
nile <- nile %>%
mutate(
time = seq(1,length(nile$hits)),
time_square = time^2,
hits_log= log(hits))
applerev <- read_excel("applerev.xlsx") %>%
mutate(date_clean = parse_date_time(date, orders = "mdy")) %>%
select(date = date_clean, revenue)
ggplot(applerev, aes(x = date, y = revenue)) +
geom_line() +
ggtitle("Chart 6: Quarterly Apple revenue (2010-09-30 to 31-12-2022)") +
labs(y = "$USD (billions)", x = "Date")
<br>
### b.) Using the steps outlined in the lecture slides, compute an appropriate decomposition of the data into its trend-cycle, seasonal and residual/remainder components. Generate appropriate plots of these components and make sure to justify any choices that you have made. (3 Marks)
<br>
Chart 7 reflects my attempt to compute an appropriate decomposition of the data. To do this I have made the following assumptions:
* Because the data is quarterly, I have constructed the seasonal part of the decomposition using a set of quarterly dummies.
* I have computed a multiplicative decomposition of this data because the seasonal trend is multiplicative. This can be deduced by the fact that the difference between annual peaks and troughs increases with revenue levels.
* To construct the trend-cycle part of the decomposition, I have used an MA(4) model. This is because the frequency of the data is quarterly, therefore I ought to choose an MA(m) model where the m is equal to the periodicity of the data's seasonal fluctuations: 4. Because the length of the data is even, I've have to specify a model which take the average of two different weighting periods.
* I have calculated the remainder series by dividing out the estimated seasonal and trend-cycle components form the level (R_hat = y_t / (T_t * S_t * C_t))
<br>
```{r q2b}
applerev <- applerev %>%
mutate(quarter = quarter(date)) %>% #Note: quarters are based on calendar years
mutate(
q1_dummy = (case_when(quarter == 1 ~ 1, TRUE ~ 0)),
q2_dummy = (case_when(quarter == 2 ~ 1, TRUE ~ 0)),
q3_dummy = (case_when(quarter == 3 ~ 1, TRUE ~ 0)),
q4_dummy = (case_when(quarter == 4 ~ 1, TRUE ~ 0))
)
model_applerev_seasonal <- lm(revenue ~ 0 + q1_dummy + q2_dummy + q3_dummy + q4_dummy, data = applerev)
applerev <- applerev %>%
mutate(seasonal = predict(model_applerev_seasonal))
print(length(applerev$date))
applerev <- applerev %>%
mutate(
trend = 1/2*(1/4*(lag(revenue,2) + lag(revenue,1) + revenue + lead(revenue,1)) + 1/4*(lag(revenue,1)  + revenue + lead(revenue,1) + lead(revenue,2)))
)
applerev <- applerev %>%
mutate(
detrended = revenue / trend
)
applerev <- applerev %>%
mutate(
remainder = revenue / (trend * seasonal)
)
applerev_manual_decomp_data <- applerev %>%
select(date, data = revenue, trend, seasonal, remainder) %>%
pivot_longer(-date) %>%
mutate(name = factor(name, levels = c("data", "trend", "seasonal", "remainder")))
ggplot(applerev_manual_decomp_data, aes(x = date, y = value)) +
geom_line() +
facet_wrap(~ name, ncol = 1, scale = "free") +
ggtitle("Chart 7: Manual decomposition of quarterly Apple Inc. revenue") +
labs(x = "Date", y = "")
<br>
### c.) Compute the same decomposition using the decompose() and compare it with the decomposition that you have computed in part (b). (1 Mark)
<br>
There are no clear differences between these two graphs: the shape of all graphs and axes are the same. Please note, due to an error with the autplot function on my device when trying to plot the output of decompose(), I've had to extract all of the content from thsi object into a separate ggplot object via a new dataframe.
The lack of difference between outputs seems to confirm I correctly replicated the automated process for multiplicatively decomposing this timeseries in part (b).
<br>
```{r q2c}
applerev_auto_decomp <- applerev %>%
pull(revenue) %>%
ts(start = c(2010,3), end = c(2022,4), frequency = 4) %>%
decompose(type = "multiplicative")
applerev_auto_decomp_data <- data.frame(applerev_auto_decomp$trend) %>%
cbind(applerev_auto_decomp$seasonal) %>%
cbind(applerev_auto_decomp$random) %>%
cbind(applerev$date) %>%
cbind(applerev$revenue) %>%
clean_names() %>%
select(date = applerev_date, data = applerev_revenue, trend = applerev_auto_decomp_trend,
seasonal = applerev_auto_decomp_seasonal, error = applerev_auto_decomp_random) %>%
pivot_longer(-date) %>%
mutate(name = factor(name, levels = c("data", "trend", "seasonal", "random")))
ggplot(applerev_manual_decomp_data, aes(x = date, y = value)) +
geom_line() +
facet_wrap(~ name, ncol = 1, scale = "free") +
ggtitle("Chart 8: Automated decomposition of quarterly Apple Inc. revenue") +
labs(x = "Date", y = "")
View(applerev)
